<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Posts | RookieIO&#39;s Tech Lab</title>
<meta name="keywords" content="">
<meta name="description" content="Posts - RookieIO&#39;s Tech Lab">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/posts/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css" integrity="sha256-2jIR5e&#43;Ge/K3X9WmUVz&#43;1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="http://localhost:1313/posts/index.xml" title="rss">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
                color-scheme: dark;
            }

            .list {
                background: var(--theme);
            }

            .toc {
                background: var(--entry);
            }
        }

        @media (prefers-color-scheme: light) {
            .list::-webkit-scrollbar-thumb {
                border-color: var(--code-bg);
            }
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    } else if (localStorage.getItem("pref-theme") === "light") {
       document.querySelector("html").dataset.theme = 'light';
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.querySelector("html").dataset.theme = 'dark';
    } else {
        document.querySelector("html").dataset.theme = 'light';
    }

</script>
</head>
<body class="list" id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="RookieIO&#39;s Tech Lab (Alt + H)">RookieIO&#39;s Tech Lab</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/posts/" title="文章">
                    <span class="active">文章</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="搜索">
                    <span>搜索</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>
    Posts
  </h1>
</header>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Test Deploy
    </h2>
  </header>
  <div class="entry-content">
    <p>🔥 Firewalld 权威参考手册 (Arch Linux 版) 属性 说明 适用系统 Arch Linux, CentOS, Fedora, RHEL, openSUSE 底层后端 nftables (新版) / iptables (旧版) 核心工具 firewall-cmd 配置文件路径 /etc/firewalld/ (用户配置), /usr/lib/firewalld/ (默认配置) 文档版本 v2.0 (终极详细版) 📖 1. 核心设计哲学 (必读) 在操作之前，必须理解 Firewalld 的两个核心概念，否则你的配置可能会重启失效，或者逻辑混乱。
1.1 运行时 (Runtime) vs 永久 (Permanent) Firewalld 的配置分两层：
Runtime (内存中): 修改立刻生效，但重启后丢失。用于测试规则。 Permanent (硬盘中): 修改写入配置文件，重载 (Reload) 后才生效。用于持久化。 💡 最佳实践: 永远使用 --permanent 参数，然后立即运行 --reload。除非你只是想临时测试一下怕把自己锁在外面。
1.2 区域 (Zones) Firewalld 将网络划分为不同的“信任等级”。网卡 (Interface) 必须绑定在某个区域里。
区域 (Zone) 信任度 默认行为 典型应用场景 drop 0% (黑洞) 丢弃所有入站包，不给任何回应。 遭受攻击时 / 极高安全环境。 block 10% (拒绝) 拒绝所有入站包，但会回复 icmp-prohibited (告诉对方被拒了)。 调试网络连通性时。 public 30% (默认) 仅允许显式放行的端口 (如 ssh, dhcpv6-client)。 公共 Wi-Fi / 默认对外网卡。 external 40% 类似 public，但默认开启 IP 伪装 (Masquerade)。 路由器 WAN 口 / 软路由出口。 home 70% 信任大多设备，开放 mdns, ssh, samba。 家庭局域网。 work 60% 类似 home，但限制更严。 公司内网。 trusted 100% 允许所有流量 (无防火墙限制)。 VPN 虚拟网卡 (tun0) / 容器内部通信。 🛠 2. 服务生命周期管理 # 启动防火墙 sudo systemctl start firewalld # 设置开机自启 sudo systemctl enable firewalld # 停止防火墙 (调试连通性第一步) sudo systemctl stop firewalld # 彻底禁用 (防止开机自启) sudo systemctl disable firewalld # 检查运行状态 (Running / Not running) sudo firewall-cmd --state # 重新加载配置 (修改 Permanent 后必须执行！) sudo firewall-cmd --reload 🔍 3. 信息查看与审计 (Information) 在修改之前，先学会怎么“看”。 # 1. 查看默认区域的所有规则 (最常用) sudo firewall-cmd --list-all # 2. 查看所有区域的详细规则 (信息量极大) sudo firewall-cmd --list-all-zones # 3. 查看当前活跃的区域 (查看网卡绑定在哪) sudo firewall-cmd --get-active-zones # 输出示例: # public # interfaces: wlan0 eth0 # trusted # interfaces: tun0 # 4. 查看系统预定义了哪些服务 (如 ssh, http, docker-registry 等) sudo firewall-cmd --get-services ⚙️ 4. 端口与服务管理 (常规操作) 场景: 开放 Web 服务、远程桌面、文件共享。 (注: 以下命令默认省略 sudo，实际使用请加上)
...</p>
  </div>
  <footer class="entry-footer"><span title='2026-01-15 09:02:47 +0800 CST'>January 15, 2026</span>&nbsp;·&nbsp;<span>3 min</span></footer>
  <a class="entry-link" aria-label="post link to Test Deploy" href="http://localhost:1313/posts/test-deploy/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">GitHub使用方法
    </h2>
  </header>
  <div class="entry-content">
    <p>GitHub 搜索语法完全指南（含实用示例） 一、基础搜索语法 1. 关键词搜索 python：搜索所有包含 “python” 的仓库/代码 &#34;machine learning&#34;：精确匹配短语 “machine learning” docker -container：搜索包含 docker 但不含 container 的结果 2. 范围限定 in:name flask：只在仓库名称中搜索 “flask” in:description web framework：只在仓库描述中搜索 in:readme &#34;quick start&#34;：只在 README 文件中搜索 repo:vuejs/vue：仅在指定仓库中搜索 二、仓库搜索技巧 1. 属性筛选 stars:&gt;1000：星标超过 1000 的仓库 forks:&gt;500：Fork 数超过 500 的仓库 size:&gt;10000：大小超过 10MB 的仓库 license:mit：MIT 许可证的仓库 archived:false：未归档的活跃仓库 2. 时间范围筛选 pushed:&gt;2024-01-01：2024 年后更新过的仓库 created:2023-01-01..2023-12-31：2023 年创建的仓库 updated:&gt;2024-06-01：最近 30 天更新的仓库 3. 实用案例 查找Python高星项目
in:name python stars:&gt;5000 查找近半年更新的AI项目
in:description AI pushed:&gt;2024-01-01 查找MIT许可的Web框架
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-11-18 13:36:41 +0800 CST'>November 18, 2025</span>&nbsp;·&nbsp;<span>2 min</span></footer>
  <a class="entry-link" aria-label="post link to GitHub使用方法" href="http://localhost:1313/posts/github%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Linux 内核 (Kernel) 编译与管理详解
    </h2>
  </header>
  <div class="entry-content">
    <p>内核(Kernel)
内核(Kernel) 计算机完成的工作们，都必须要内核支持才行。内核其实就是系统上面的一个文件。该文件包含了驱动主机各项硬件的检测程序与驱动模块。主机上可以拥有多个内核文件。启动的时候只能选择一个加载。 Linux很早就使用模块化设置（将一些不常用的类似驱动程序的东西独立出内核，编译成模块）。内核可以在系统正常运行的过程中加载模块。在不修改内核的前提下，加载编译过的适当内核模块就可以使用这个硬件。简单又方便。模块存放在/lib/modules/$(uname -r)/kernnel/中 内核文件是通过源代码编译而成。内核是直接读入到内存中。必须要编译成系统可识别的数据才行。 可以获取内核的源代码，利用Tarball安装方式完成内核编译。
更新内核的目的 需要Linux做什么？没有必要的工作就不要加入内核。系统已经将内核编译得相当适合一般用户使用了，一般用户基本上不需要编译内核
内核源代码得获取方式： Linux发行版在推出得时候已经附上内核源代码了。主要源代码在下面网站上 全部的 CentOS 原始 SRPM：http://vault.centos.org/ CentOS 7.1 的 SRPM：http://vault.centos.org/7.1.1503/ 内核官网：http://www.kernel.org/ 中国科技大学镜像站:http://centos.ustc.edu.cn/linux-kernel/ 清华大学镜像站:https://mirrors.tuna.tsinghua.edu.cn/kernel/
利用patch升级内核源代码： 内核发布时，除了完整得内核压缩文件外，也会发布[该版本与前一版本得差异性patche文件]。每个内核的patche文件仅针对前一内核版本来分析。想要由3.10.85升级到3.10.89的话，就需要下载 patch-3.10.86， patch-3.10.87， patch-3.10.88， patch-3.10.89等文件，然后依序一个一个的进行patch操作。 如果某个硬件或者非官方发布的内核功能patch文件，必须了解该patch文件适用的内核版本。
内核源代码的解压缩、安装、查看 从CentOS官网获取的SRPM或是从Linux内核官网获取的Tarball内核源代码，都会有一个tarball的内核源代码。 从Linux内核官网获取linux-3.10.89.tar.xz内核文件。地址： ftp://ftp.twaren.net/pub/Unix/Kernel/linux/kernel/v3.x/linux-3.10.89.tar.xz
内核源代码的解压缩与放置目录 假设从官网下载内核源代码文件在/root下（建议放置在/usr/src/kernels） [root@study ~]# tar -Jxvf linux-3.10.89.tar.xz -C /usr/src/kernels/ 会在/usr/src/kernels下产生一个新目录Linux-3.10.89.（内核的编译与设置必须在此目录下进行）。 内核源代码下的子目录：（内核目录下重要的数据） arch ：硬件平台有关的项目，大部分指的是 CPU 的类别，如 x86， x86_64， Xen 虚拟化支持等; block ：块设备较相关的设置，块数据通常指大容量存储设备！ 包括是否支持类似 ext3 等文件系统。 crypto ：内核支持的加密技术，例如 md5 或者是 des 等等; Documentation ：内核有关的说明文件，对内核有极大的兴趣，可以看看！ drivers ：一些硬件的驱动程序，例如显卡、网卡、PCI 相关硬件等; firmware ：一些旧硬件的固件; fs ：内核支持的文件系统(filesystems) ，例如 vfat， reiserfs， nfs 等; include ：可让其他程序调用的头（header）文件; init ：内核初始化的功能，包括挂载与 init 程序的调用等; ipc ：定义 Linux 操作系统内各程序间的通信; kernel ：定义内核的程序、内核状态、线程、进程的调度 （schedule）、进程的信号 （signle） 等 lib ：函式库; mm ：内存单元有关的各项数据，包括 swap 与虚拟内存等; net ：网络有关的协议数据，还有防火墙模块 （net/ipv4/netfilter/*） 等等; security ：包括 selinux 等在内的安全性设置; sound ：音效有关的各项模块; virt ：虚拟化有关的信息，目前内核支持的是 KVM （Kernel base Virtual Machine）
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-11-12 00:00:00 +0000 UTC'>November 12, 2025</span>&nbsp;·&nbsp;<span>11 min</span></footer>
  <a class="entry-link" aria-label="post link to Linux 内核 (Kernel) 编译与管理详解" href="http://localhost:1313/posts/linux-kernel/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Linux中文件系统各个目录的作用
    </h2>
  </header>
  <div class="entry-content">
    <p>核心目录结构 / (根目录) 包含了几乎所有的文件目录。相当于中央系统。
/boot (引导程序、内核等存放的目录) 这个目录包括了在引导过程中所必需的文件。在最开始的启动阶段，通过引导程序将内核加载到内存，完成内核的启动（这个时候，虚拟文件系统还不存在，加载的内核虽然是从硬盘读取的，但是没经过 Linux 的虚拟文件系统，这是比较底层的东西来实现的）。
然后内核自己创建好虚拟文件系统，并且从虚拟文件系统的其他子目录中（例如 /sbin 和 /etc）加载需要在开机启动的其他程序或者服务或者特定的动作（部分可以由用户自己在相应的目录中修改相应的文件来配制）。
如果我们的机器中包含多个操作系统，那么可以通过修改这个目录中的某个配置文件（例如 grub.conf）来调整启动的默认操作系统、系统启动的选择菜单，以及启动延迟等参数。
/sbin (超级用户可以使用的命令的存放目录) 存放大多涉及系统管理的命令（例如引导系统的 init 程序），是超级权限用户 root 的可执行命令存放地，普通用户无权限执行这个目录下的命令（但是有时普通用户也可能会用到）。
我们要记住，凡是目录 sbin 中包含的都是 root 权限才能执行的。
/bin (普通用户可以使用的命令的存放目录) 系统所需要的那些命令位于此目录，比如 ls、cp、mkdir 等命令；类似的目录还 /usr/bin，/usr/local/bin 等等。这个目录中的文件都是可执行的、普通用户都可以使用的命令。作为基础系统所需要的最基础的命令就是放在这里。
/lib (根目录下的所有程序的共享库目录) 此目录下包含系统引导和在根用户执行命令时候所必需用到的共享库。做个不太好但是比较形象的比喻，有点类似于 Windows 上面的 system32 目录。
理论上，这里存放的文件应该是 /bin 目录下程序所需要的库文件的存放地，也不排除一些例外的情况。类似的目录还 /usr/lib，/usr/local/lib 等等。
/dev (设备文件目录) 在 Linux 中设备都是以文件形式出现，这里的设备可以是硬盘，键盘，鼠标，网卡，终端等设备，通过访问这些文件可以访问到相应的设备。
设备文件可以使用 mknod 命令来创建；而为了将对这些设备文件的访问转化为对设备的访问，需要向相应的设备提供设备驱动模块（一般将设备驱动编译之后，生成的结果是一个 *.ko 类型的二进制文件，在内核启动之后，再通过 insmod 等命令加载相应的设备驱动之后，我们就可以通过设备文件来访问设备了）。
一般来说，想要 Linux 系统支持某个设备，需要相应的硬件设备、支持硬件的驱动模块，以及相应的设备文件。
/home (普通用户的家目录) 在 Linux 机器上，用户主目录通常直接或间接地置在此目录下。其结构通常由本地机的管理员来决定。
通常而言，系统的每个用户都有自己的家目录，目录以用户名作为名字存放在 /home 下面（例如 josonlee 用户，其家目录的名字为 /home/josonlee）。该目录中保存了绝大多数的用户文件 (用户自己的配置文件、定制文件、文档、数据等)。
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-11-12 00:00:00 +0000 UTC'>November 12, 2025</span>&nbsp;·&nbsp;<span>2 min</span></footer>
  <a class="entry-link" aria-label="post link to Linux中文件系统各个目录的作用" href="http://localhost:1313/posts/my-first-post/"></a>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2026 <a href="http://localhost:1313/">RookieIO&#39;s Tech Lab</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
